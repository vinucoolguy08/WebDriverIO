{
  "script": "return (function drawTabbableOnCanvas(drawOptions) {\n    window.scrollTo(0, 0);\n    var width = window.innerWidth;\n    var height = getDocumentScrollHeight();\n    var canvasNode = \"<canvas id=\\\"wic-tabbable-canvas\\\" width=\\\"\".concat(width, \"\\\" height=\\\"\").concat(height, \"\\\" style=\\\"position:absolute;top:0;left:0;z-index:999999;\\\">\");\n    document.body.insertAdjacentHTML('afterbegin', canvasNode);\n    var accessibleElements = tabbable();\n    var elementCoordinates = accessibleElements.map(function (node) {\n        var currentElement = node.getBoundingClientRect();\n        return {\n            x: currentElement.left + (currentElement.width / 2),\n            y: currentElement.top + (currentElement.height / 2),\n        };\n    });\n    elementCoordinates.unshift({ x: 0, y: 0 });\n    elementCoordinates.forEach(function (elementCoordinate, i) {\n        if (i === 0) {\n            return;\n        }\n        drawLine(drawOptions.line, elementCoordinates[i - 1], elementCoordinate);\n        drawCircleAndNumber(drawOptions.circle, elementCoordinate, i);\n    });\n    function drawLine(options, start, end) {\n        var tabbableCanvasContext = document.getElementById('wic-tabbable-canvas').getContext('2d');\n        tabbableCanvasContext.beginPath();\n        tabbableCanvasContext.globalCompositeOperation = 'destination-over';\n        tabbableCanvasContext.lineWidth = options.width;\n        tabbableCanvasContext.strokeStyle = options.color;\n        tabbableCanvasContext.moveTo(start.x, start.y);\n        tabbableCanvasContext.lineTo(end.x, end.y);\n        tabbableCanvasContext.stroke();\n    }\n    function drawCircleAndNumber(options, position, i) {\n        var tabbableCanvasContext = document.getElementById('wic-tabbable-canvas').getContext('2d');\n        tabbableCanvasContext.beginPath();\n        tabbableCanvasContext.globalCompositeOperation = 'source-over';\n        tabbableCanvasContext.fillStyle = options.backgroundColor;\n        tabbableCanvasContext.arc(position.x, position.y, options.size, 0, Math.PI * 2, true);\n        tabbableCanvasContext.fill();\n        tabbableCanvasContext.lineWidth = options.borderWidth;\n        tabbableCanvasContext.strokeStyle = options.borderColor;\n        tabbableCanvasContext.stroke();\n        if (options.showNumber) {\n            tabbableCanvasContext.font = \"\".concat(options.fontSize, \"px \").concat(options.fontFamily);\n            tabbableCanvasContext.textAlign = 'center';\n            tabbableCanvasContext.textBaseline = 'middle';\n            tabbableCanvasContext.fillStyle = options.fontColor;\n            tabbableCanvasContext.fillText(i.toString(), position.x, position.y);\n        }\n    }\n    function tabbable() {\n        var regularTabbables = [];\n        var orderedTabbables = [];\n        var candidateSelectors = [\n            'input',\n            'select',\n            'textarea',\n            'a[href]',\n            'button',\n            '[tabindex]',\n            'audio[controls]',\n            'video[controls]',\n            '[contenteditable]:not([contenteditable=\"false\"])',\n        ].join(',');\n        var candidates = document.querySelectorAll(candidateSelectors);\n        for (var i = 0; i < candidates.length; i++) {\n            var candidate = candidates[i];\n            if (!isNodeMatchingSelectorTabbable(candidate)) {\n                continue;\n            }\n            var candidateTabindex = getTabindex(candidate);\n            if (candidateTabindex === 0) {\n                regularTabbables.push(candidate);\n            }\n            else {\n                orderedTabbables.push({\n                    documentOrder: i,\n                    tabIndex: candidateTabindex,\n                    node: candidate,\n                });\n            }\n        }\n        return Array.prototype.slice.call(orderedTabbables.sort(sortOrderedTabbables).map(function (a) { return a.node; }).concat(regularTabbables));\n    }\n    function isNodeMatchingSelectorTabbable(node) {\n        return !(!isNodeMatchingSelectorFocusable(node) ||\n            isNonTabbableRadio(node) ||\n            getTabindex(node) < 0);\n    }\n    function isNodeMatchingSelectorFocusable(node) {\n        return !((node.hasAttribute('disabled') || node.getAttribute('disabled'))\n            || isHiddenInput(node)\n            || isHidden(node));\n    }\n    function getTabindex(node) {\n        var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);\n        if (!isNaN(tabindexAttr)) {\n            return tabindexAttr;\n        }\n        if (isContentEditable(node)) {\n            return 0;\n        }\n        return node.tabIndex;\n    }\n    function sortOrderedTabbables(nodeA, nodeB) {\n        return nodeA.tabIndex === nodeB.tabIndex\n            ? nodeA.documentOrder - nodeB.documentOrder\n            : nodeA.tabIndex - nodeB.tabIndex;\n    }\n    function isContentEditable(node) {\n        return node.contentEditable === 'true';\n    }\n    function isInput(node) {\n        return node.tagName === 'INPUT';\n    }\n    function isHiddenInput(node) {\n        return isInput(node) && node.type === 'hidden';\n    }\n    function isRadio(node) {\n        return isInput(node) && node.type === 'radio';\n    }\n    function isNonTabbableRadio(node) {\n        return isRadio(node) && !isTabbableRadio(node);\n    }\n    function getCheckedRadio(nodes) {\n        for (var i = 0; i < nodes.length; i++) {\n            if (nodes[i].checked) {\n                return nodes[i];\n            }\n        }\n    }\n    function isTabbableRadio(node) {\n        if (!node.name) {\n            return true;\n        }\n        var radioSet = node.ownerDocument.querySelectorAll(\"input[type=\\\"radio\\\"][name=\\\"\".concat(node.name, \"\\\"]\"));\n        var checked = getCheckedRadio(radioSet);\n        return !checked || checked === node;\n    }\n    function isHidden(node) {\n        return (node.offsetParent === null || getComputedStyle(node).visibility === 'hidden');\n    }\n    function getDocumentScrollHeight() {\n        var viewPortHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n        var scrollHeight = document.documentElement.scrollHeight;\n        var bodyScrollHeight = document.body.scrollHeight;\n        if ((viewPortHeight === scrollHeight) && (bodyScrollHeight > scrollHeight)) {\n            return bodyScrollHeight;\n        }\n        var pageHeight = 0;\n        var largestNodeElement = document.querySelector('body');\n        if (bodyScrollHeight === scrollHeight && bodyScrollHeight === viewPortHeight) {\n            findHighestNode(document.documentElement.childNodes);\n            return pageHeight + largestNodeElement.getBoundingClientRect().top;\n        }\n        return scrollHeight;\n        function findHighestNode(nodesList) {\n            for (var i = nodesList.length - 1; i >= 0; i--) {\n                var currentNode = nodesList[i];\n                if (currentNode.scrollHeight && currentNode.clientHeight) {\n                    var elHeight = Math.max(currentNode.scrollHeight, currentNode.clientHeight);\n                    pageHeight = Math.max(elHeight, pageHeight);\n                    if (elHeight === pageHeight) {\n                        largestNodeElement = currentNode;\n                    }\n                }\n                if (currentNode.childNodes.length) {\n                    findHighestNode(currentNode.childNodes);\n                }\n            }\n        }\n    }\n}).apply(null, arguments)",
  "args": [
    {
      "circle": {
        "backgroundColor": "#ff0000",
        "borderColor": "#000",
        "borderWidth": 1,
        "fontColor": "#fff",
        "fontFamily": "Arial",
        "fontSize": 10,
        "size": 10,
        "showNumber": true
      },
      "line": {
        "color": "#000",
        "width": 1
      }
    }
  ]
}