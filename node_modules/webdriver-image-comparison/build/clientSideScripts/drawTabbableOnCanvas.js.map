{"version":3,"file":"drawTabbableOnCanvas.js","sourceRoot":"","sources":["../../lib/clientSideScripts/drawTabbableOnCanvas.ts"],"names":[],"mappings":"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","sourcesContent":["import {ElementCoordinate} from './drawTabbableOnCanvas.interfaces';\nimport {CircleOptions, LineOptions, TabbableOptions} from '../commands/tabbable.interfaces';\n\n/**\n * This method is based on this blog post\n * https://vivrichards.co.uk/accessibility/automating-page-tab-flows-using-visual-testing-and-javascript\n * by Viv Richards and optimized for using Canvas\n */\nexport default function drawTabbableOnCanvas(drawOptions: TabbableOptions) {\n  // 1. Scroll to top of page\n  window.scrollTo(0, 0);\n\n  // 2. Insert canvas\n  const width = window.innerWidth;\n  const height = getDocumentScrollHeight();\n  const canvasNode = `<canvas id=\"wic-tabbable-canvas\" width=\"${width}\" height=\"${height}\" style=\"position:absolute;top:0;left:0;z-index:999999;\">`;\n  document.body.insertAdjacentHTML('afterbegin', canvasNode);\n\n  // 3. Get all the elements\n  const accessibleElements = tabbable();\n\n  // 4a. Iterate over all accessibleElements and get the coordinates\n  const elementCoordinates: ElementCoordinate[] = accessibleElements.map(node => {\n    const currentElement = node.getBoundingClientRect();\n\n    return {\n      x: currentElement.left + (currentElement.width / 2),\n      y: currentElement.top + (currentElement.height / 2),\n    };\n  });\n  // 4b. Add the starting coordinates\n  elementCoordinates.unshift({x: 0, y: 0});\n  // 4c. Iterate over all coordinates and draw lines and circles\n  elementCoordinates.forEach((elementCoordinate, i) => {\n    if (i === 0) {\n      return;\n    }\n\n    drawLine(drawOptions.line, elementCoordinates[i - 1], elementCoordinate);\n    drawCircleAndNumber(drawOptions.circle, elementCoordinate, i);\n  });\n\n  /**\n   * Draw a line\n   */\n  function drawLine(options: LineOptions, start: ElementCoordinate, end: ElementCoordinate): void {\n    const tabbableCanvasContext = (<HTMLCanvasElement>document.getElementById('wic-tabbable-canvas')).getContext('2d');\n\n    // Draw the line\n    tabbableCanvasContext.beginPath();\n    tabbableCanvasContext.globalCompositeOperation = 'destination-over';\n    tabbableCanvasContext.lineWidth = options.width;\n    tabbableCanvasContext.strokeStyle = options.color;\n    tabbableCanvasContext.moveTo(start.x, start.y);\n    tabbableCanvasContext.lineTo(end.x, end.y);\n    tabbableCanvasContext.stroke();\n  }\n\n  /**\n   * Draw a circle\n   */\n  function drawCircleAndNumber(options: CircleOptions, position: ElementCoordinate, i: number): void {\n    const tabbableCanvasContext = (<HTMLCanvasElement>document.getElementById('wic-tabbable-canvas')).getContext('2d');\n\n    // Draw circle\n    tabbableCanvasContext.beginPath();\n    tabbableCanvasContext.globalCompositeOperation = 'source-over';\n    tabbableCanvasContext.fillStyle = options.backgroundColor;\n    tabbableCanvasContext.arc(position.x, position.y, options.size, 0, Math.PI * 2, true);\n    tabbableCanvasContext.fill();\n    // Draw border\n    tabbableCanvasContext.lineWidth = options.borderWidth;\n    tabbableCanvasContext.strokeStyle = options.borderColor;\n    tabbableCanvasContext.stroke();\n\n    if (options.showNumber) {\n      // Set the text\n      tabbableCanvasContext.font = `${options.fontSize}px ${options.fontFamily}`;\n      tabbableCanvasContext.textAlign = 'center';\n      tabbableCanvasContext.textBaseline = 'middle';\n      tabbableCanvasContext.fillStyle = options.fontColor;\n      tabbableCanvasContext.fillText(i.toString(), position.x, position.y);\n    }\n  }\n\n  /**\n   * Below code is coming from https://github.com/davidtheclark/tabbable\n   * and is modified a bit to work inside the browser.\n   * The original module couldn't be used for injection and didn't support TypeScript\n   */\n\n  /**\n   * Get all tabbable elements based on tabindex and then regular dom order\n   */\n  function tabbable(): HTMLElement[] {\n    let regularTabbables = [];\n    let orderedTabbables = [];\n    const candidateSelectors = [\n      'input',\n      'select',\n      'textarea',\n      'a[href]',\n      'button',\n      '[tabindex]',\n      'audio[controls]',\n      'video[controls]',\n      '[contenteditable]:not([contenteditable=\"false\"])',\n    ].join(',');\n    let candidates: NodeListOf<HTMLElement> = document.querySelectorAll(candidateSelectors);\n\n    for (let i = 0; i < candidates.length; i++) {\n      const candidate = candidates[i];\n\n      if (!isNodeMatchingSelectorTabbable(candidate)) {\n        continue;\n      }\n\n      const candidateTabindex = getTabindex(candidate);\n\n      if (candidateTabindex === 0) {\n        regularTabbables.push(candidate);\n      } else {\n        orderedTabbables.push({\n          documentOrder: i,\n          tabIndex: candidateTabindex,\n          node: candidate,\n        });\n      }\n    }\n\n    return Array.prototype.slice.call(orderedTabbables.sort(<any>sortOrderedTabbables).map(a => a.node).concat(regularTabbables));\n  }\n\n  /**\n   * Is the node tabbable\n   */\n  function isNodeMatchingSelectorTabbable(node: HTMLElement): boolean {\n    return !(\n      !isNodeMatchingSelectorFocusable(node) ||\n      isNonTabbableRadio(node) ||\n      getTabindex(node) < 0\n    );\n  }\n\n  /**\n   * Check if the node has a focused state\n   */\n  function isNodeMatchingSelectorFocusable(node: HTMLElement): boolean {\n    return !(\n      (node.hasAttribute('disabled') || node.getAttribute('disabled'))\n      || isHiddenInput(node)\n      || isHidden(node)\n    );\n  }\n\n  /**\n   * Get the tab index of the node\n   */\n  function getTabindex(node: HTMLElement): number {\n    const tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);\n\n    if (!isNaN(tabindexAttr)) {\n      return tabindexAttr;\n    }\n    // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n    // so if they don't have a tabindex attribute specifically set, assume it's 0.\n    if (isContentEditable(node)) {\n      return 0;\n    }\n\n    return node.tabIndex;\n  }\n\n  /**\n   * Return ordered tabbable nodes\n   */\n  function sortOrderedTabbables(nodeA: HTMLElement, nodeB: HTMLElement): number {\n    return nodeA.tabIndex === nodeB.tabIndex\n      // This is so bad :(, fix this!\n      ? (<any>nodeA).documentOrder - (<any>nodeB).documentOrder\n      : nodeA.tabIndex - nodeB.tabIndex;\n  }\n\n  /**\n   * Is the content editable\n   */\n  function isContentEditable(node: HTMLElement): boolean {\n    return node.contentEditable === 'true';\n  }\n\n  /**\n   * Is the node an input\n   */\n  function isInput(node: HTMLElement): boolean {\n    return node.tagName === 'INPUT';\n  }\n\n  /**\n   * Is the input hidden\n   */\n  function isHiddenInput(node: HTMLElement): boolean {\n    return isInput(node) && (<HTMLInputElement>node).type === 'hidden';\n  }\n\n  /**\n   * Is the node a radio input\n   */\n  function isRadio(node: HTMLElement): boolean {\n    return isInput(node) && (<HTMLInputElement>node).type === 'radio';\n  }\n\n  /**\n   * Is the node a radio input and can it be tabbed\n   */\n  function isNonTabbableRadio(node: HTMLElement): boolean {\n    return isRadio(node) && !isTabbableRadio(<HTMLInputElement>node);\n  }\n\n  /**\n   * Get the checked radio input\n   */\n  // @ts-ignore\n  function getCheckedRadio(nodes: HTMLInputElement[]) {\n    for (let i = 0; i < nodes.length; i++) {\n      if (nodes[i].checked) {\n        return nodes[i];\n      }\n    }\n  }\n\n  /**\n   * Is the radio input tabbable\n   */\n  function isTabbableRadio(node: HTMLInputElement):boolean {\n    if (!node.name) {\n      return true;\n    }\n    // This won't account for the edge case where you have radio groups with the same\n    // in separate forms on the same page.\n    // This is bad :(, but don't know how to fix this typing\n    let radioSet = (<any>node.ownerDocument).querySelectorAll(\n      `input[type=\"radio\"][name=\"${node.name}\"]`\n    );\n    let checked = getCheckedRadio(radioSet);\n\n    return !checked || checked === node;\n  }\n\n  /**\n   * Is the node hidden\n   */\n  function isHidden(node: HTMLElement): boolean {\n    // offsetParent being null will allow detecting cases where an element is invisible or inside an invisible element,\n    // as long as the element does not use position: fixed. For them, their visibility has to be checked directly as well.\n    return (\n      node.offsetParent === null || getComputedStyle(node).visibility === 'hidden'\n    );\n  }\n\n  /**\n   * Get the document scroll height\n   */\n  function getDocumentScrollHeight(): number {\n    const viewPortHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n    const scrollHeight = document.documentElement.scrollHeight;\n    const bodyScrollHeight = document.body.scrollHeight;\n\n    // In some situations the default scrollheight can be equal to the viewport height\n    // but the body scroll height can be different, then return that one\n    if ((viewPortHeight === scrollHeight) && (bodyScrollHeight > scrollHeight)) {\n      return bodyScrollHeight;\n    }\n\n    // In some cases we can have a challenge determining the height of the page\n    // due to for example a `vh` property on the body element.\n    // If that is the case we need to walk over all the elements and determine the highest element\n    // this is a very time consuming thing, so our last hope :(\n    let pageHeight = 0;\n    let largestNodeElement = document.querySelector('body');\n\n    if (bodyScrollHeight === scrollHeight && bodyScrollHeight === viewPortHeight) {\n      findHighestNode(document.documentElement.childNodes);\n\n      // There could be some elements above this largest element,\n      // add that on top\n      return pageHeight + largestNodeElement.getBoundingClientRect().top;\n    }\n\n    // The scrollHeight is good enough\n    return scrollHeight;\n\n    /**\n     * Find the largest html element on the page\n     */\n    // This is so bad :(, fix the typings!!!\n    function findHighestNode(nodesList: any) {\n      for (let i = nodesList.length - 1; i >= 0; i--) {\n        const currentNode = nodesList[i];\n\n        /* istanbul ignore next */\n        if (currentNode.scrollHeight && currentNode.clientHeight) {\n          const elHeight = Math.max(currentNode.scrollHeight, currentNode.clientHeight);\n          pageHeight = Math.max(elHeight, pageHeight);\n          if (elHeight === pageHeight) {\n            largestNodeElement = currentNode;\n          }\n        }\n\n        if (currentNode.childNodes.length) {\n          findHighestNode(currentNode.childNodes);\n        }\n      }\n    }\n  }\n}\n"]}